<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-IDS - Artificial Intelligence Intrusion Detection System</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 40, 0.9));
            color: white;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            border-bottom: 2px solid #007bff;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-start;
        }

        .sidebar-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
            margin-bottom: 5px;
        }

        .sidebar-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .header h1 {
            font-size: 28px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header h1 i {
            color: #007bff;
            font-size: 32px;
        }

        .subtitle {
            font-size: 14px;
            color: #a0a0a0;
            font-weight: 400;
            margin-left: 44px;
        }

        .header .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .header .auth-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header .auth-link {
            color: white;
            text-decoration: none;
            padding: 10px 18px;
            border-radius: 6px;
            background: rgba(255,255,255,0.15);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .header .auth-link:hover {
            background: rgba(255,255,255,0.25);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .header .auth-error {
            color: #dc3545;
            padding: 8px 16px;
            border-radius: 4px;
            background: rgba(220, 53, 69, 0.1);
            border: 1px solid rgba(220, 53, 69, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .user-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-online { background-color: #28a745; }
        .status-offline { background-color: #dc3545; }
        .status-warning { background-color: #ffc107; }
        
        .camera-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 4px;
            margin-left: auto;
        }
        
        .camera-status.online {
            background-color: rgba(40, 167, 69, 0.1);
            color: #28a745;
        }
        
        .camera-status.offline {
            background-color: rgba(220, 53, 69, 0.1);
            color: #dc3545;
        }
        
        .camera-status .status-indicator.online {
            background-color: #28a745;
        }
        
        .camera-status .status-indicator.offline {
            background-color: #dc3545;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Main Container */
        .main-container {
            display: flex;
            height: calc(100vh - 70px);
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px 0;
            transition: all 0.3s ease;
            position: relative;
        }

        .sidebar.collapsed {
            width: 0;
            padding: 20px 0;
            overflow: hidden;
        }

        .main-container {
            display: flex;
            flex: 1;
            transition: all 0.3s ease;
        }

        .main-container.sidebar-collapsed {
            margin-left: -250px;
        }

        .nav-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-item.active {
            background: rgba(0, 123, 255, 0.3);
            border-left: 4px solid #007bff;
        }

        /* Content Area */
        .content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Control Panel */
        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .btn-primary { background: #007bff; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-secondary { background: #6c757d; color: white; }

        /* Video Grid */
        .video-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 20px;
            max-width: 100%;
        }

        .video-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .video-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #ddd;
            flex-wrap: wrap;
            gap: 8px;
        }

        .video-title {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .video-status-container {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .video-status {
            font-size: 11px;
            padding: 3px 6px;
            border-radius: 3px;
            background: #28a745;
            color: white;
        }

        .camera-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            padding: 3px 6px;
            border-radius: 3px;
        }

        .camera-status .status-text {
            white-space: nowrap;
        }

        .camera-status.online {
            background: rgba(40, 167, 69, 0.1);
            color: #28a745;
        }

        .camera-status.offline {
            background: rgba(220, 53, 69, 0.1);
            color: #dc3545;
        }

        .video-feed {
            width: 100%;
            height: auto;
            min-height: 300px;
            max-height: 450px;
            background: #000;
            border-radius: 6px;
            object-fit: contain;
        }

        /* Recordings Panel */
        .recordings-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .recordings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        .recordings-header h3 {
            color: #2c3e50;
            margin: 0;
            font-size: 1.5rem;
        }

        .recordings-stats {
            display: flex;
            gap: 20px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .recordings-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .recordings-controls .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .recordings-controls label {
            font-size: 12px;
            font-weight: 600;
            color: #495057;
            text-transform: uppercase;
        }

        .recordings-controls select {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        .recordings-controls select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }

        .recordings-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .recording-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }

        .recording-item:hover {
            background: #e9ecef;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .recording-info {
            flex: 1;
        }

        .recording-filename {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
            font-size: 0.95rem;
        }

        .recording-filename i {
            color: #17a2b8;
            margin-right: 8px;
        }

        .recording-details {
            display: flex;
            gap: 15px;
            color: #666;
            font-size: 0.85rem;
        }

        .recording-detail {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .recording-detail i {
            font-size: 0.8rem;
            color: #6c757d;
        }

        .recording-actions {
            margin-left: 15px;
            display: flex;
            gap: 8px;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 0.8rem;
        }

        .no-recordings, .error {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .recording-date {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8rem;
            color: #495057;
            margin-right: 8px;
        }

        .filter-group label {
            font-size: 12px;
            font-weight: 600;
            color: #495057;
            text-transform: uppercase;
        }

        /* Log Panel */
        .log-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }

        .log-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-group label {
            font-size: 12px;
            font-weight: 600;
            color: #495057;
            text-transform: uppercase;
        }

        .filter-group select,
        .filter-group input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        .filter-group select:focus,
        .filter-group input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }

        .log-container {
            max-height: 500px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .log-entry {
            padding: 8px 12px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .log-entry.alert {
            background: #fff5f5;
            border-left: 4px solid #dc3545;
        }

        .log-entry.obstruction-session {
            background: #e6f7ff;
            border-left: 4px solid #17a2b8;
            cursor: pointer;
            transition: background 0.2s;
        }

        .log-entry.obstruction-session:hover {
            background: #d1ecf1;
        }

        .session-toggle {
            margin-right: 5px;
            font-size: 10px;
            transition: transform 0.2s;
        }

        .session-details {
            background: #f8f9fa;
            border-left: 4px solid #17a2b8;
            margin: 0;
            padding: 15px;
            border-bottom: 1px solid #f0f0f0;
            animation: slideDown 0.3s ease;
        }

        .session-details-content {
            margin-left: 20px;
        }

        .session-details-content h4 {
            margin: 0 0 10px 0;
            color: #17a2b8;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #e9ecef;
            font-size: 12px;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-weight: 600;
            color: #495057;
        }

        .detail-value {
            color: #333;
        }

        .alert-triggered {
            color: #28a745;
            font-weight: bold;
        }

        .alert-not-triggered {
            color: #6c757d;
        }

        .notification-sent {
            color: #28a745;
            font-weight: bold;
        }

        .notification-not-sent {
            color: #6c757d;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 300px;
            }
        }

        .log-time {
            color: #666;
            font-size: 11px;
            min-width: 80px;
        }

        .log-type {
            font-weight: bold;
            min-width: 100px;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }

        .log-message {
            flex: 1;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        /* Charts Grid */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }

        .chart-header h3 {
            margin: 0;
            color: #333;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-header select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        .chart-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 15px 0;
        }

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        /* Comparison Section */
        .comparison-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .comparison-section h3 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .comparison-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e9ecef;
        }

        .comparison-card h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 14px;
            text-align: center;
        }

        /* Security Score Display */
        .score-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .score-circle {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: conic-gradient(#28a745 0deg 306deg, #dc3545 306deg 360deg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .score-circle::before {
            content: '';
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: white;
        }

        .score-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            z-index: 1;
        }

        .score-label {
            font-size: 12px;
            color: #666;
            z-index: 1;
        }

        .score-factors {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .factor {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background: white;
            border-radius: 4px;
            font-size: 12px;
        }

        .factor-label {
            color: #666;
        }

        .factor-value {
            font-weight: bold;
            color: #333;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 14px;
        }

        /* Settings Panel */
        .settings-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .setting-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .setting-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #007bff;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(26px);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 10px 15px;
            }
            
            .header h1 {
                font-size: 20px;
            }
            
            .sidebar {
                position: fixed;
                left: 0;
                top: 70px;
                height: calc(100vh - 70px);
                z-index: 1000;
                transform: translateX(-100%);
            }
            
            .sidebar.collapsed {
                transform: translateX(0);
            }
            
            .main-container.sidebar-collapsed {
                margin-left: 0;
            }
            
            .content {
                padding: 10px;
            }
            
            .video-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <button class="sidebar-toggle" id="sidebarToggle">
                <i class="fas fa-bars"></i>
            </button>
            <h1><i class="fas fa-shield-alt"></i> AI Intrusion Detection System</h1>
            <div class="subtitle">Advanced CCTV Security Monitoring</div>
        </div>
        <div class="status-bar">
            <div class="status-item">
                <span class="status-indicator status-online" id="camera-status"></span>
                <span id="camera-status-text">System Online</span>
            </div>
            <div class="status-item">
                <i class="fas fa-clock"></i>
                <span id="current-time"></span>
            </div>
            <div class="status-item">
                <i class="fas fa-bell"></i>
                <span id="alert-count">0 Alerts</span>
            </div>
        </div>
        <div class="auth-section" id="authSection">
            <!-- Auth links will be dynamically inserted here -->
        </div>
    </header>

    <div class="main-container">
        <nav class="sidebar">
            <div class="nav-item active" data-tab="monitoring">
                <i class="fas fa-video"></i>
                <span>Live Monitoring</span>
            </div>
            <div class="nav-item" data-tab="logs">
                <i class="fas fa-list-alt"></i>
                <span>Event Logs</span>
            </div>
            <div class="nav-item" data-tab="recordings">
                <i class="fas fa-film"></i>
                <span>Recordings</span>
            </div>
            <div class="nav-item" data-tab="analytics">
                <i class="fas fa-chart-bar"></i>
                <span>Analytics</span>
            </div>
            <div class="nav-item" data-tab="settings">
                <i class="fas fa-cog"></i>
                <span>Settings</span>
            </div>
        </nav>

        <main class="content">
            <!-- Monitoring Tab -->
            <div class="tab-content active" id="monitoring">
                <div class="control-panel">
                    <h3><i class="fas fa-sliders-h"></i> AI-IDS Controls</h3>
                    <div class="control-buttons">
                        <button class="btn btn-warning" onclick="toggleManual()">
                            <i class="fas fa-exclamation-triangle"></i> Test Alert
                        </button>
                        <button class="btn btn-info" onclick="toggleInject()">
                            <i class="fas fa-bug"></i> Inject Attack
                        </button>
                    </div>
                </div>

                <div class="video-grid">
                    <div class="video-panel">
                        <div class="video-header">
                            <span class="video-title">Camera 1 - Main Entrance</span>
                            <div class="video-status-container">
                                <span class="video-status" id="cam1-status">LIVE</span>
                            </div>
                        </div>
                        <img id="video-feed" class="video-feed" src="/video_feed" alt="Camera Feed">
                    </div>
                </div>
            </div>

            <!-- Logs Tab -->
            <div class="tab-content" id="logs">
                <div class="log-panel">
                    <div class="log-header">
                        <h3><i class="fas fa-list"></i> Event Logs</h3>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-secondary" onclick="clearLogs()">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                            <button class="btn btn-info" onclick="exportLogs()">
                                <i class="fas fa-download"></i> Export
                            </button>
                        </div>
                    </div>
                    
                    <!-- Filter and Sort Controls -->
                    <div class="log-controls">
                        <div class="filter-group">
                            <label>Filter by Type:</label>
                            <select id="log-filter" onchange="filterLogs()">
                                <option value="all">All Events</option>
                                <option value="ALERT">Alerts</option>
                                <option value="OBSTRUCTION_SESSION">Obstruction Sessions</option>
                                <option value="MANUAL_ATTACK_SESSION">Manual Attack Sessions</option>
                                <option value="INJECT_ATTACK_SESSION">Inject Attack Sessions</option>
                                <option value="AI_NETWORK_ATTACK">AI Network Attacks</option>
                                <option value="DOS_FLOOD">DDoS Flood</option>
                                <option value="PORT_SCAN">Port Scan</option>
                                <option value="UNAUTHORIZED_ACCESS">Unauthorized Access</option>
                                <option value="WEB_EXPLOIT">Web Exploit</option>
                                <option value="ATTACK_SIMULATION">Attack Simulations</option>
                                <option value="INFO">Info</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Grouping:</label>
                            <select id="log-grouping" onchange="filterLogs()">
                                <option value="all">Show All</option>
                                <option value="grouped">Grouped Only</option>
                                <option value="individual">Individual Only</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Sort by:</label>
                            <select id="log-sort" onchange="sortLogs()">
                                <option value="newest">Newest First</option>
                                <option value="oldest">Oldest First</option>
                                <option value="type">Event Type</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Search:</label>
                            <input type="text" id="log-search" placeholder="Search logs..." oninput="filterLogs()">
                        </div>
                    </div>
                    
                    <div class="log-container" id="detection-log"></div>
                </div>
            </div>

            <!-- Recordings Tab -->
            <div class="tab-content" id="recordings">
                <div class="recordings-panel">
                    <div class="recordings-header">
                        <h3><i class="fas fa-video"></i> CCTV Recordings</h3>
                        <div class="recordings-stats" id="recordings-stats">
                            <div class="stat-item">
                                <span class="stat-label">Total Files:</span>
                                <span class="stat-value" id="total-files">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Total Size:</span>
                                <span class="stat-value" id="total-size">0 MB</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Filters and Controls -->
                    <div class="recordings-controls">
                        <div class="filter-group">
                            <label>Date Filter:</label>
                            <select id="date-filter" onchange="loadRecordings()">
                                <option value="">All Dates</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Sort By:</label>
                            <select id="sort-by" onchange="loadRecordings()">
                                <option value="date">Date</option>
                                <option value="name">Filename</option>
                                <option value="size">Size</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Order:</label>
                            <select id="sort-order" onchange="loadRecordings()">
                                <option value="desc">Newest First</option>
                                <option value="asc">Oldest First</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <button class="btn btn-secondary" onclick="refreshRecordings()">
                                <i class="fas fa-sync"></i> Refresh
                            </button>
                        </div>
                    </div>
                    
                    <!-- Recordings List -->
                    <div class="recordings-list" id="recordings-list">
                        <div class="loading">Loading recordings...</div>
                    </div>
                </div>
            </div>

            <!-- Analytics Tab -->
            <div class="tab-content" id="analytics">
                <!-- Summary Stats -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="total-attacks">0</div>
                        <div class="stat-label">Total Attacks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="network-attacks">0</div>
                        <div class="stat-label">Network Attacks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="cctv-attacks">0</div>
                        <div class="stat-label">CCTV Attacks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="uptime">0h</div>
                        <div class="stat-label">System Uptime</div>
                    </div>
                </div>

                <!-- Charts Section -->
                <div class="charts-grid">
                    <!-- Event Distribution Pie Chart -->
                    <div class="chart-panel">
                        <div class="chart-header">
                            <h3><i class="fas fa-chart-pie"></i> Event Distribution</h3>
                            <select id="pie-chart-period" onchange="updateCharts()">
                                <option value="all">All Time</option>
                                <option value="today">Today</option>
                                <option value="hour">Last Hour</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="event-pie-chart" width="300" height="300"></canvas>
                        </div>
                        <div class="chart-legend" id="pie-legend"></div>
                    </div>

                    <!-- Timeline Chart -->
                    <div class="chart-panel">
                        <div class="chart-header">
                            <h3><i class="fas fa-chart-line"></i> Event Timeline</h3>
                            <select id="timeline-period" onchange="updateCharts()">
                                <option value="hour">Last Hour</option>
                                <option value="day">Last 24 Hours</option>
                                <option value="week">Last Week</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="timeline-chart" width="400" height="300"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Comparison Section -->
                <div class="comparison-section">
                    <h3><i class="fas fa-balance-scale"></i> Event Comparison</h3>
                    <div class="comparison-grid">
                        <div class="comparison-card">
                            <h4>Hourly Comparison</h4>
                            <canvas id="hourly-comparison" width="300" height="200"></canvas>
                        </div>
                        <div class="comparison-card">
                            <h4>Event Types Breakdown</h4>
                            <canvas id="type-breakdown" width="300" height="200"></canvas>
                        </div>
                        <div class="comparison-card">
                            <h4>Security Score</h4>
                            <div class="score-display">
                                <div class="score-circle" id="security-score">
                                    <span class="score-value">85</span>
                                    <span class="score-label">Score</span>
                                </div>
                                <div class="score-factors">
                                    <div class="factor">
                                        <span class="factor-label">Threat Level:</span>
                                        <span class="factor-value" id="threat-level">Low</span>
                                    </div>
                                    <div class="factor">
                                        <span class="factor-label">Response Time:</span>
                                        <span class="factor-value" id="response-time">2.3s</span>
                                    </div>
                                    <div class="factor">
                                        <span class="factor-label">Accuracy:</span>
                                        <span class="factor-value" id="accuracy">98%</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings Tab -->
            <div class="tab-content" id="settings">
                <div class="settings-panel">
                <h3><i class="fas fa-cog"></i> AI-IDS Settings</h3>
                    
                    <div class="setting-group">
                        <label class="setting-label">Motion Sensitivity</label>
                        <input type="range" class="setting-input" min="1" max="10" value="5">
                    </div>
                    
                    <div class="setting-group">
                        <div class="setting-toggle">
                            <label class="setting-label">Enable Sound Alerts</label>
                            <div class="toggle-switch active" id="sound-toggle"></div>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <div class="setting-toggle">
                            <label class="setting-label">Enable Email Notifications</label>
                            <div class="toggle-switch" id="email-toggle"></div>
                        </div>
                    </div>
                    
                    <div class="control-buttons">
                        <button class="btn btn-primary" onclick="saveSettings()">
                            <i class="fas fa-save"></i> Save Settings
                        </button>
                        <button class="btn btn-secondary" onclick="resetSettings()">
                            <i class="fas fa-undo"></i> Reset to Default
                        </button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        let soundEnabled = true; // Default sound to ON
        let statusInterval;
        let startTime = Date.now();
        let eventStats = {
            total: 0,
            obstruction: 0,
            alerts: 0
        };

        // Sidebar toggle functionality
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const mainContainer = document.querySelector('.main-container');
            const toggleBtn = document.getElementById('sidebarToggle');
            
            sidebar.classList.toggle('collapsed');
            mainContainer.classList.toggle('sidebar-collapsed');
            
            // Change icon based on sidebar state
            if (sidebar.classList.contains('collapsed')) {
                toggleBtn.innerHTML = '<i class="fas fa-bars"></i>';
            } else {
                toggleBtn.innerHTML = '<i class="fas fa-times"></i>';
            }
        }

        // Add event listener for sidebar toggle
        document.addEventListener('DOMContentLoaded', function() {
            const sidebarToggle = document.getElementById('sidebarToggle');
            if (sidebarToggle) {
                sidebarToggle.addEventListener('click', toggleSidebar);
            }
        });

        // Authentication functions
        async function updateAuthSection() {
            const authSection = document.getElementById('authSection');
            
            if (!authSection) {
                console.warn('Auth section element not found');
                return;
            }
            
            try {
                // Get user data from backend
                const response = await fetch('/api/get-user-profile');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('User profile data:', data); // Debug log
                
                if (data.success && data.user) {
                    const username = data.user.username || 'User';
                    const userInitial = username ? username.charAt(0).toUpperCase() : 'U';
                    
                    // Update sessionStorage for consistency
                    sessionStorage.setItem('isLoggedIn', 'true');
                    sessionStorage.setItem('username', username);
                    sessionStorage.setItem('email', data.user?.email || '');
                    sessionStorage.setItem('role', data.user?.role || 'User');
                    
                    authSection.innerHTML = `
                        <div class="user-info" style="display: flex; align-items: center; gap: 10px; margin-right: 10px;">
                            <i class="fas fa-user-circle" style="font-size: 24px; color: #007bff;"></i>
                            <span style="font-weight: 500;">${username}</span>
                        </div>
                        <a href="/profile" class="auth-link" style="background: rgba(0,123,255,0.3); border: 1px solid rgba(0,123,255,0.5);">
                            <i class="fas fa-user"></i>
                            <span>Profile</span>
                        </a>
                        <a href="#" class="auth-link" onclick="logout(event); return false;" style="background: rgba(220,53,69,0.3); border: 1px solid rgba(220,53,69,0.5);">
                            <i class="fas fa-sign-out-alt"></i>
                            <span>Logout</span>
                        </a>
                    `;
            } else {
                // This shouldn't happen since dashboard is protected, but handle gracefully
                authSection.innerHTML = `
                    <div class="auth-error">
                        <i class="fas fa-exclamation-triangle"></i>
                        Authentication Error
                    </div>
                `;
            }
            } catch (error) {
                console.error('Error fetching user profile:', error);
                
                // Fallback to sessionStorage if API fails
                const username = sessionStorage.getItem('username') || localStorage.getItem('username') || 'User';
                const userInitial = username ? username.charAt(0).toUpperCase() : 'U';
                
                if (username !== 'User') {
                    // User has some session data, show it
                    authSection.innerHTML = `
                        <div class="user-info" style="display: flex; align-items: center; gap: 10px; margin-right: 10px;">
                            <i class="fas fa-user-circle" style="font-size: 24px; color: #007bff;"></i>
                            <span style="font-weight: 500;">${username}</span>
                        </div>
                        <a href="/profile" class="auth-link" style="background: rgba(0,123,255,0.3); border: 1px solid rgba(0,123,255,0.5);">
                            <i class="fas fa-user"></i>
                            <span>Profile</span>
                        </a>
                        <a href="#" class="auth-link" onclick="logout(event); return false;" style="background: rgba(220,53,69,0.3); border: 1px solid rgba(220,53,69,0.5);">
                            <i class="fas fa-sign-out-alt"></i>
                            <span>Logout</span>
                        </a>
                    `;
                } else {
                    // No user data found, show error
                    authSection.innerHTML = `
                        <div class="auth-error">
                            <i class="fas fa-exclamation-triangle"></i>
                            Session Error
                        </div>
                    `;
                }
            }
        }

        function logout(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            if (confirm('Are you sure you want to logout?')) {
                // Clear frontend storage
                sessionStorage.clear();
                localStorage.clear();
                
                // Call backend logout
                fetch('/logout', {
                    method: 'GET',
                    credentials: 'include'
                }).then(() => {
                    window.location.href = '/login';
                }).catch((error) => {
                    console.error('Logout error:', error);
                    // Even if backend call fails, redirect to login
                    window.location.href = '/login';
                });
            }
            return false;
        }

        // Initialize auth section on page load
        document.addEventListener('DOMContentLoaded', function() {
            // User is authenticated (backend already verified)
            updateAuthSection();
            
            // Check camera status and update UI
            checkCameraStatus();
            
            // Initialize sidebar navigation (will be called again in window.onload, but this ensures early initialization)
            setTimeout(() => {
                if (typeof initializeTabs === 'function') {
                    initializeTabs();
                }
            }, 100);
        });

        // Load recordings
        async function loadRecordings() {
            try {
                // Check if elements exist
                const dateFilterEl = document.getElementById('date-filter');
                const sortByEl = document.getElementById('sort-by');
                const sortOrderEl = document.getElementById('sort-order');
                
                if (!dateFilterEl || !sortByEl || !sortOrderEl) {
                    console.warn('Recordings filter elements not found, tab may not be visible');
                    return;
                }
                
                // Get filter values
                const dateFilter = dateFilterEl.value || '';
                const sortBy = sortByEl.value || 'date';
                const sortOrder = sortOrderEl.value || 'desc';
                
                // Build query string
                const queryParams = new URLSearchParams({
                    sort: sortBy,
                    order: sortOrder,
                    date: dateFilter
                });
                
                const response = await fetch(`/api/recordings?${queryParams}`);
                const data = await response.json();
                
                const recordingsList = document.getElementById('recordings-list');
                
                if (data.error) {
                    recordingsList.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                    return;
                }
                
                // Update statistics
                updateRecordingsStats(data.statistics);
                
                // Update date filter dropdown
                updateDateFilter(data.available_dates, dateFilter);
                
                if (data.recordings && data.recordings.length > 0) {
                    recordingsList.innerHTML = data.recordings.map(recording => `
                        <div class="recording-item">
                            <div class="recording-info">
                                <div class="recording-filename">
                                    <i class="fas fa-video"></i>
                                    ${recording.filename}
                                </div>
                                <div class="recording-details">
                                    <div class="recording-detail">
                                        <i class="fas fa-calendar"></i>
                                        <span>${recording.created}</span>
                                    </div>
                                    <div class="recording-detail">
                                        <i class="fas fa-file"></i>
                                        <span>${recording.size_mb} MB</span>
                                    </div>
                                    <div class="recording-detail">
                                        <i class="fas fa-clock"></i>
                                        <span>${recording.duration}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="recording-actions">
                                <a href="${recording.download_url}" class="btn btn-primary btn-sm" title="Download recording">
                                    <i class="fas fa-download"></i>
                                </a>
                            </div>
                        </div>
                    `).join('');
                } else {
                    recordingsList.innerHTML = '<div class="no-recordings">No recordings available</div>';
                }
            } catch (error) {
                console.error('Error loading recordings:', error);
                document.getElementById('recordings-list').innerHTML = '<div class="error">Error loading recordings</div>';
            }
        }

        // Update recordings statistics
        function updateRecordingsStats(stats) {
            const totalFilesEl = document.getElementById('total-files');
            const totalSizeEl = document.getElementById('total-size');
            
            if (!totalFilesEl || !totalSizeEl) {
                console.warn('Recordings stats elements not found');
                return;
            }
            
            if (stats) {
                totalFilesEl.textContent = stats.total_count || 0;
                totalSizeEl.textContent = formatFileSize(stats.total_size || 0);
            }
        }

        // Update date filter dropdown
        function updateDateFilter(availableDates, selectedDate) {
            const dateFilter = document.getElementById('date-filter');
            if (!dateFilter) {
                console.warn('Date filter element not found');
                return;
            }
            const currentValue = dateFilter.value;
            
            // Clear existing options except "All Dates"
            dateFilter.innerHTML = '<option value="">All Dates</option>';
            
            // Add available dates
            availableDates.forEach(date => {
                const option = document.createElement('option');
                option.value = date;
                option.textContent = formatDate(date);
                if (date === selectedDate || date === currentValue) {
                    option.selected = true;
                }
                dateFilter.appendChild(option);
            });
        }

        // Format date for display
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { 
                weekday: 'short', 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        }

        // Refresh recordings
        function refreshRecordings() {
            document.getElementById('recordings-list').innerHTML = '<div class="loading">Refreshing recordings...</div>';
            loadRecordings();
        }

        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initialize
        window.onload = function() {
            // Load recordings on page load if recordings tab is active
            loadRecordings();
        };

        // Initialize - Optimized for faster loading
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tab navigation (critical - do first)
            initializeTabs();
            
            // Start clock immediately (lightweight)
            updateClock();
            setInterval(updateClock, 1000);
            
            // Defer heavy operations to improve initial page load
            // Wait 500ms before first status update
            setTimeout(() => {
                updateStatus();
                // Then start regular intervals
                setInterval(updateStatus, 2000);
            }, 500);
            
            // Defer analytics update (less critical)
            setTimeout(() => {
                updateAnalytics();
                setInterval(updateAnalytics, 5000);
            }, 1000);
            
            // Load recordings only when recordings tab is clicked (lazy loading)
            const recordingsTab = document.querySelector('[data-tab="recordings"]');
            if (recordingsTab) {
                recordingsTab.addEventListener('click', loadRecordings);
            }
            
            // Load saved settings
            const savedSettings = localStorage.getItem('cctv-settings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                if (settings.soundEnabled !== undefined) {
                    if (settings.soundEnabled) {
                        document.getElementById('sound-toggle').classList.add('active');
                        soundEnabled = true;
                    } else {
                        document.getElementById('sound-toggle').classList.remove('active');
                        soundEnabled = false;
                    }
                }
                if (settings.emailEnabled) {
                    document.getElementById('email-toggle').classList.add('active');
                }
            } else {
                // Default settings - sound is ON
                document.getElementById('sound-toggle').classList.add('active');
                soundEnabled = true;
            }
            
            // Sound toggle
            const soundToggle = document.getElementById('sound-toggle');
            if (soundToggle) {
                soundToggle.addEventListener('click', function() {
                    this.classList.toggle('active');
                    soundEnabled = this.classList.contains('active');
                    
                    // Save settings
                    if (typeof saveSettings === 'function') {
                        saveSettings();
                    }
                });
            }
            
            // Email toggle
            document.getElementById('email-toggle').addEventListener('click', function() {
                this.classList.toggle('active');
            });
            
            // Initial status update
            updateStatus();
        });

        // Tab Navigation (unified function)
        function initializeTabs() {
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                // Remove any existing listeners to prevent duplicates
                const newItem = item.cloneNode(true);
                item.parentNode.replaceChild(newItem, item);
                
                // Add click listener
                newItem.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const tabName = this.getAttribute('data-tab') || this.dataset.tab;
                    if (tabName) {
                        console.log('Tab clicked:', tabName);
                        switchTab(tabName);
                    }
                });
            });
        }
        
        // Alias for consistency
        function initializeSidebarNavigation() {
            initializeTabs();
        }

        function switchTab(tabName) {
            try {
                // Update nav items
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                const targetNavItem = document.querySelector(`[data-tab="${tabName}"]`);
                if (targetNavItem) {
                    targetNavItem.classList.add('active');
                }

                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                const targetTabContent = document.getElementById(tabName);
                if (targetTabContent) {
                    targetTabContent.classList.add('active');
                }
                
                // Load data when switching to specific tabs
                if (tabName === 'recordings' && typeof loadRecordings === 'function') {
                    // Small delay to ensure tab is visible
                    setTimeout(() => {
                        loadRecordings();
                    }, 100);
                }
                
                // Load logs when switching to logs tab
                if (tabName === 'logs' && typeof updateStatus === 'function') {
                    // Trigger status update to load logs
                    setTimeout(() => {
                        updateStatus();
                    }, 100);
                }
            } catch (error) {
                console.error('Error switching tab:', error);
            }
        }

        // Update clock
        function updateClock() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            document.getElementById('current-time').textContent = timeString;
        }

        // Control functions
        async function toggleManual() {
            await sendControl('toggle_manual');
        }

        async function toggleInject() {
            await sendControl('toggle_inject');
        }

        async function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = event.target.closest('.btn') || document.getElementById('soundButton');
            if (btn) {
                btn.innerHTML = soundEnabled ? 
                    '<i class="fas fa-volume-up"></i> Sound: ON' : 
                    '<i class="fas fa-volume-up"></i> Sound: OFF';
                btn.className = soundEnabled ? 'btn btn-success' : 'btn btn-secondary';
            }
            
            // Sync with settings toggle
            const soundToggle = document.getElementById('sound-toggle');
            if (soundToggle) {
                if (soundEnabled) {
                    soundToggle.classList.add('active');
                } else {
                    soundToggle.classList.remove('active');
                }
            }
            
            // Save settings
            if (typeof saveSettings === 'function') {
                saveSettings();
            }
        }

        function clearLogs() {
            if (confirm('Are you sure you want to clear all logs?')) {
                fetch('/api/clear_logs', { method: 'POST' })
                    .then(() => {
                        document.getElementById('detection-log').innerHTML = '<div class="log-entry">Logs cleared</div>';
                        eventStats = { total: 0, obstruction: 0, alerts: 0 };
                        updateAnalytics([]); // Pass empty array to reset analytics
                    });
            }
        }

        // Camera control functions

        async function checkCameraStatus() {
            try {
                const response = await fetch('/api/camera/status');
                const data = await response.json();
                
                if (data.success) {
                    updateCameraStatus(data.camera_connected);
                }
            } catch (error) {
                console.error('Error checking camera status:', error);
            }
        }

        function updateCameraStatus(isConnected) {
            // Disconnected text removed - status is now only shown via cam1-status
            // This function is kept for compatibility but doesn't update disconnected text
        }

        function showNotification(message, type) {
            // Simple notification system
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 10px 20px;
                border-radius: 5px;
                color: white;
                font-weight: bold;
                z-index: 10000;
                ${type === 'success' ? 'background-color: #28a745;' : 'background-color: #dc3545;'}
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 3000);
        }

        function exportLogs() {
            const logData = getAllLogs();
            if (logData.length === 0) {
                showNotification('No logs to export', 'info');
                return;
            }
            
            // Create CSV content
            let csv = 'Time,Event Type,Reason\n';
            logData.forEach(entry => {
                csv += `"${entry.time}","${entry.event_type}","${entry.reason}"\n`;
            });
            
            // Download CSV file
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-ids-logs-${new Date().toISOString().slice(0,10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            showNotification('Logs exported successfully!', 'success');
        }

        function getAllLogs() {
            // Get logs from the current display or fetch from server
            const logEntries = document.querySelectorAll('.log-entry');
            const logs = [];
            
            logEntries.forEach(entry => {
                const time = entry.querySelector('.log-time')?.textContent;
                const type = entry.querySelector('.log-type')?.textContent;
                const message = entry.querySelector('.log-message')?.textContent;
                
                if (time && type && message) {
                    logs.push({ time, event_type: type, reason: message });
                }
            });
            
            return logs;
        }

        function filterLogs() {
            const filterEl = document.getElementById('log-filter');
            const groupingEl = document.getElementById('log-grouping');
            const searchEl = document.getElementById('log-search');
            const logContainer = document.getElementById('detection-log');
            
            if (!filterEl || !groupingEl || !searchEl || !logContainer) {
                console.warn('Filter elements not found');
                return;
            }
            
            const filterType = filterEl.value;
            const groupingType = groupingEl.value;
            const searchTerm = searchEl.value.toLowerCase();
            const logEntries = logContainer.querySelectorAll('.log-entry');
            
            logEntries.forEach(entry => {
                const typeEl = entry.querySelector('.log-type');
                const messageEl = entry.querySelector('.log-message');
                
                if (!typeEl || !messageEl) {
                    entry.style.display = 'none';
                    return;
                }
                
                const type = typeEl.textContent.trim();
                const message = messageEl.textContent.toLowerCase();
                const isGrouped = entry.classList.contains('obstruction-session');
                
                // Match filter type (exact match or 'all')
                let matchesFilter = filterType === 'all';
                if (!matchesFilter) {
                    // Check exact match
                    matchesFilter = type === filterType;
                    // Also check for partial matches for attack types
                    if (!matchesFilter) {
                        matchesFilter = type.includes(filterType) || filterType.includes(type);
                    }
                }
                
                // Match search term
                const matchesSearch = searchTerm === '' || 
                                    message.includes(searchTerm) || 
                                    type.toLowerCase().includes(searchTerm);
                
                // Apply grouping filter
                let matchesGrouping = true;
                if (groupingType === 'grouped') {
                    matchesGrouping = isGrouped;
                } else if (groupingType === 'individual') {
                    matchesGrouping = !isGrouped;
                }
                
                // Show/hide entry based on all filters
                entry.style.display = matchesFilter && matchesSearch && matchesGrouping ? 'flex' : 'none';
            });
        }

        function sortLogs() {
            const sortEl = document.getElementById('log-sort');
            if (!sortEl) {
                console.warn('Sort element not found');
                return;
            }
            
            const sortType = sortEl.value;
            const logContainer = document.getElementById('detection-log');
            
            if (!logContainer) {
                console.warn('Log container not found');
                return;
            }
            
            const logEntries = Array.from(logContainer.querySelectorAll('.log-entry'));
            
            if (logEntries.length === 0) return;
            
            logEntries.sort((a, b) => {
                switch(sortType) {
                    case 'newest':
                        const timeA = a.querySelector('.log-time')?.textContent || '';
                        const timeB = b.querySelector('.log-time')?.textContent || '';
                        // Try to parse as date for better sorting
                        try {
                            const dateA = new Date(timeA);
                            const dateB = new Date(timeB);
                            if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
                                return dateB - dateA;
                            }
                        } catch (e) {}
                        return timeB.localeCompare(timeA);
                    
                    case 'oldest':
                        const timeC = a.querySelector('.log-time')?.textContent || '';
                        const timeD = b.querySelector('.log-time')?.textContent || '';
                        try {
                            const dateC = new Date(timeC);
                            const dateD = new Date(timeD);
                            if (!isNaN(dateC.getTime()) && !isNaN(dateD.getTime())) {
                                return dateC - dateD;
                            }
                        } catch (e) {}
                        return timeC.localeCompare(timeD);
                    
                    case 'type':
                        const typeA = a.querySelector('.log-type')?.textContent || '';
                        const typeB = b.querySelector('.log-type')?.textContent || '';
                        return typeA.localeCompare(typeB);
                    
                    default:
                        return 0;
                }
            });
            
            // Re-append sorted entries
            logEntries.forEach(entry => {
                logContainer.appendChild(entry);
            });
            
            // Re-apply filters after sorting
            filterLogs();
        }

        // API communication
        async function sendControl(action) {
            try {
                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ action: action })
                });
                const result = await response.json();
                if (result.error) {
                    console.error('Control error:', result.error);
                } else {
                    updateStatus();
                }
            } catch (error) {
                console.error('Error sending control:', error);
            }
        }

        // Update system status (with request throttling)
        let statusUpdateInProgress = false;
        async function updateStatus() {
            // Prevent concurrent requests
            if (statusUpdateInProgress) {
                return;
            }
            
            statusUpdateInProgress = true;
            try {
                const response = await fetch('/api/status');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                // Update header status
                if (typeof updateHeaderStatus === 'function') {
                    updateHeaderStatus(data);
                }
                
                // Update camera status
                if (typeof updateCameraStatus === 'function') {
                    updateCameraStatus(data);
                }
                
                // Update log
                if (typeof updateLog === 'function') {
                    updateLog(data.log);
                }
                
                // Update analytics with actual data
                if (typeof updateAnalytics === 'function') {
                    updateAnalytics(data.log);
                }
                
                // Play sound if needed (only when sound_active changes to true)
                if (soundEnabled && data.sound_active && typeof playAlertSound === 'function') {
                    // Track previous sound_active state to play sound only once when it becomes true
                    if (!window.lastSoundActive && data.sound_active) {
                        playAlertSound();
                        // Play sound multiple times for better visibility (3 beeps)
                        setTimeout(() => playAlertSound(), 600);
                        setTimeout(() => playAlertSound(), 1200);
                    }
                    window.lastSoundActive = data.sound_active;
                } else {
                    window.lastSoundActive = false;
                }
                
            } catch (error) {
                console.error('Error updating status:', error);
            } finally {
                statusUpdateInProgress = false;
            }
        }

        function updateHeaderStatus(data) {
            const cameraStatus = document.getElementById('camera-status');
            const cameraStatusText = document.getElementById('camera-status-text');
            
            if (data.camera_connected) {
                cameraStatus.className = 'status-indicator status-online';
                cameraStatusText.textContent = 'Camera Online';
            } else {
                cameraStatus.className = 'status-indicator status-offline';
                cameraStatusText.textContent = 'Camera Offline';
            }
            
            // Update alert count
            const alertCount = data.log.filter(entry => 
                entry.event_type === 'ALERT' || entry.event_type === 'SOUND_ALERT'
            ).length;
            document.getElementById('alert-count').textContent = `${alertCount} Alerts`;
        }

        function updateCameraStatus(data) {
            const cam1Status = document.getElementById('cam1-status');
            if (data.camera_connected) {
                cam1Status.textContent = 'LIVE';
                cam1Status.style.background = '#28a745';
            } else {
                cam1Status.textContent = 'OFFLINE';
                cam1Status.style.background = '#dc3545';
            }
        }

        function updateLog(logData) {
            const logEl = document.getElementById('detection-log');
            
            // Check if log element exists
            if (!logEl) {
                console.warn('Log container element not found');
                return;
            }
            
            if (!logData || logData.length === 0) {
                if (logEl.children.length === 0) {
                    logEl.innerHTML = '<div class="log-entry"><span class="log-time">--:--:--</span><span class="log-type">INFO</span><span class="log-message">No detection events</span></div>';
                }
                return;
            }
            
            // Store complete log data for filtering/sorting
            window.allLogData = logData;
            
            // Initialize displayed IDs set if not exists
            if (!window.displayedLogIds) {
                window.displayedLogIds = new Set();
            }
            
            // Get currently displayed log IDs
            const existingIds = new Set();
            const existingEntries = logEl.querySelectorAll('.log-entry');
            existingEntries.forEach(entry => {
                const logId = entry.getAttribute('data-log-id');
                if (logId) {
                    existingIds.add(logId);
                    window.displayedLogIds.add(logId);
                }
            });
            
            // Sort logs by timestamp (newest first) for display
            const sortedLogs = [...logData].sort((a, b) => {
                const timeA = a.timestamp || a.time || '';
                const timeB = b.timestamp || b.time || '';
                return timeB.localeCompare(timeA);
            });
            
            // Always rebuild to ensure consistency with backend data
            logEl.innerHTML = '';
            window.displayedLogIds.clear();
            
            // Ensure all entries have IDs
            sortedLogs.forEach(entry => {
                if (!entry.id) {
                    entry.id = 'log_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                }
            });
            
            // Display latest 200 entries (newest first)
            sortedLogs.slice(0, 200).forEach(entry => {
                if (!window.displayedLogIds.has(entry.id)) {
                    const logEntry = createLogEntry(entry);
                    logEntry.setAttribute('data-log-id', entry.id);
                    logEl.appendChild(logEntry);
                    window.displayedLogIds.add(entry.id);
                }
            });
            
            // Apply current filters after display
            setTimeout(() => {
                filterLogs();
            }, 100);
        }

        function createLogEntry(entry) {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            
            // Add special styling for all session types
            if (entry.event_type === 'OBSTRUCTION_SESSION' || 
                entry.event_type === 'MANUAL_ATTACK_SESSION' || 
                entry.event_type === 'INJECT_ATTACK_SESSION') {
                
                logEntry.className += ' obstruction-session';
                
                // Add expandable functionality
                logEntry.onclick = () => toggleSessionDetails(entry, logEntry);
                
                // Get event type color
                let typeColor = '#17a2b8';
                let icon = 'fa-camera';
                if (entry.event_type === 'MANUAL_ATTACK_SESSION') {
                    typeColor = '#dc3545';
                    icon = 'fa-user-shield';
                } else if (entry.event_type === 'INJECT_ATTACK_SESSION') {
                    typeColor = '#fd7e14';
                    icon = 'fa-bug';
                }
                
                // Format time properly
                let displayTime = entry.time || entry.timestamp || 'N/A';
                if (entry.timestamp && !entry.time) {
                    try {
                        const date = new Date(entry.timestamp);
                        displayTime = date.toLocaleString('en-US', { 
                            year: 'numeric', 
                            month: '2-digit', 
                            day: '2-digit', 
                            hour: '2-digit', 
                            minute: '2-digit', 
                            second: '2-digit',
                            hour12: false 
                        });
                    } catch (e) {
                        displayTime = entry.timestamp;
                    }
                }
                
                logEntry.innerHTML = `
                    <span class="log-time">${displayTime}</span>
                    <span class="log-type" style="background: ${typeColor}; color: white;">${entry.event_type || 'INFO'}</span>
                    <span class="log-message">
                        <i class="fas ${icon} session-toggle"></i>
                        ${entry.reason || 'No reason provided'}
                    </span>
                `;
                
                return logEntry;
            }
            
            // Add alert styling
            if (entry.event_type === 'ALERT') {
                logEntry.className += ' alert';
            }
            
            // Get event type color
            let typeColor = '#6c757d';
            switch(entry.event_type) {
                case 'ALERT': typeColor = '#dc3545'; break;
                case 'OBSTRUCTION_SESSION': typeColor = '#17a2b8'; break;
                case 'MANUAL_ATTACK_SESSION': typeColor = '#dc3545'; break;
                case 'INJECT_ATTACK_SESSION': typeColor = '#fd7e14'; break;
                case 'INFO': typeColor = '#6c757d'; break;
            }
            
            // Format time properly
            let displayTime = entry.time || entry.timestamp || 'N/A';
            if (entry.timestamp && !entry.time) {
                try {
                    const date = new Date(entry.timestamp);
                    displayTime = date.toLocaleString('en-US', { 
                        year: 'numeric', 
                        month: '2-digit', 
                        day: '2-digit', 
                        hour: '2-digit', 
                        minute: '2-digit', 
                        second: '2-digit',
                        hour12: false 
                    });
                } catch (e) {
                    displayTime = entry.timestamp;
                }
            }
            
            logEntry.innerHTML = `
                <span class="log-time">${displayTime}</span>
                <span class="log-type" style="background: ${typeColor}; color: white;">${entry.event_type || 'INFO'}</span>
                <span class="log-message">${entry.reason || 'No reason provided'}</span>
            `;
            
            return logEntry;
        }

        function toggleSessionDetails(entry, logEntry) {
            const existingDetails = logEntry.nextElementSibling;
            const toggleIcon = logEntry.querySelector('.session-toggle');
            
            if (existingDetails && existingDetails.className === 'session-details') {
                // Hide details
                existingDetails.remove();
                toggleIcon.className = 'fas fa-chevron-right session-toggle';
            } else {
                // Show details
                const details = createSessionDetails(entry);
                logEntry.parentNode.insertBefore(details, logEntry.nextSibling);
                toggleIcon.className = 'fas fa-chevron-down session-toggle';
            }
        }

        function createSessionDetails(entry) {
            const details = document.createElement('div');
            details.className = 'session-details';
            
            const sessionData = entry.session_data || {};
            let title = 'Obstruction Session Details';
            let icon = 'fa-camera';
            let additionalDetails = '';
            
            if (entry.event_type === 'MANUAL_ATTACK_SESSION') {
                title = 'Manual Attack Session Details';
                icon = 'fa-user-shield';
                additionalDetails = `
                    <div class="detail-row">
                        <span class="detail-label">Attack Type:</span>
                        <span class="detail-value">${sessionData.attack_type || 'Manual'}</span>
                    </div>
                `;
            } else if (entry.event_type === 'INJECT_ATTACK_SESSION') {
                title = 'Inject Attack Session Details';
                icon = 'fa-bug';
                additionalDetails = `
                    <div class="detail-row">
                        <span class="detail-label">Attack Type:</span>
                        <span class="detail-value">${sessionData.attack_type || 'Inject'}</span>
                    </div>
                `;
            } else {
                // Obstruction session details
                additionalDetails = `
                    <div class="detail-row">
                        <span class="detail-label">Reason:</span>
                        <span class="detail-value">${sessionData.reason || 'N/A'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Sound Alert:</span>
                        <span class="detail-value ${sessionData.sound_alert ? 'alert-triggered' : 'alert-not-triggered'}">
                            ${sessionData.sound_alert ? '✓ Triggered' : '✗ Not Triggered'}
                        </span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Notification Sent:</span>
                        <span class="detail-value ${sessionData.notification_sent ? 'notification-sent' : 'notification-not-sent'}">
                            ${sessionData.notification_sent ? '✓ Sent' : '✗ Not Sent'}
                        </span>
                    </div>
                `;
            }
            
            details.innerHTML = `
                <div class="session-details-content">
                    <h4><i class="fas ${icon}"></i> ${title}</h4>
                    <div class="detail-row">
                        <span class="detail-label">Session ID:</span>
                        <span class="detail-value">${sessionData.session_id || 'N/A'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Start Time:</span>
                        <span class="detail-value">${sessionData.start_time || 'N/A'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">End Time:</span>
                        <span class="detail-value">${sessionData.end_time || 'N/A'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Duration:</span>
                        <span class="detail-value">${sessionData.duration ? sessionData.duration.toFixed(1) + 's' : 'N/A'}</span>
                    </div>
                    ${additionalDetails}
                </div>
            `;
            
            return details;
        }

        // Filter attack events only (exclude login/logout and other non-attack events)
        function filterAttackEvents(logData) {
            if (!logData || !Array.isArray(logData)) return [];
            
            // Define attack event types
            const attackEventTypes = [
                'DOS_FLOOD', 'DDOS',
                'PORT_SCAN',
                'BRUTE_FORCE', 'BRUTE_FORCE_ATTEMPT',
                'UNAUTHORIZED_ACCESS',
                'WEB_EXPLOIT',
                'AI_NETWORK_ATTACK',
                'VIDEO_INJECTION',
                'FRAME_FREEZE',
                'MOTION_MASKING',
                'CABLE_CUTTING',
                'OBSTRUCTION_DETECTED', 'OBSTRUCTION_SESSION',
                'INJECT_ATTACK_SESSION', 'INJECT_ATTACK_TRIGGER',
                'MANUAL_ATTACK_SESSION', 'MANUAL_ATTACK_TRIGGER',
                'ALERT' // Include alerts as they may indicate attacks
            ];
            
            return logData.filter(entry => {
                const eventType = entry.event_type || '';
                return attackEventTypes.includes(eventType);
            });
        }
        
        function getAttackFriendlyName(eventType) {
            const friendlyNames = {
                'DOS_FLOOD': 'DDoS/DoS Flood',
                'DDOS': 'DDoS/DoS Flood',
                'PORT_SCAN': 'Port Scan',
                'BRUTE_FORCE': 'Brute Force',
                'BRUTE_FORCE_ATTEMPT': 'Brute Force',
                'UNAUTHORIZED_ACCESS': 'Unauthorized Access',
                'WEB_EXPLOIT': 'Web Exploit',
                'AI_NETWORK_ATTACK': 'AI Network Attack',
                'VIDEO_INJECTION': 'Video Injection',
                'FRAME_FREEZE': 'Frame Freeze',
                'MOTION_MASKING': 'Motion Masking',
                'CABLE_CUTTING': 'Cable Cutting',
                'OBSTRUCTION_DETECTED': 'Obstruction',
                'OBSTRUCTION_SESSION': 'Obstruction',
                'INJECT_ATTACK_SESSION': 'Inject Attack',
                'INJECT_ATTACK_TRIGGER': 'Inject Attack',
                'MANUAL_ATTACK_SESSION': 'Manual Attack',
                'MANUAL_ATTACK_TRIGGER': 'Manual Attack',
                'ALERT': 'Alert'
            };
            return friendlyNames[eventType] || eventType;
        }

        // Analytics update with throttling
        let analyticsUpdateInProgress = false;
        function updateAnalytics(logData) {
            // Prevent concurrent analytics updates
            if (analyticsUpdateInProgress) {
                return;
            }
            
            analyticsUpdateInProgress = true;
            
            try {
                // Calculate uptime (lightweight)
                const uptime = Date.now() - startTime;
                const hours = Math.floor(uptime / (1000 * 60 * 60));
                const minutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
                const uptimeElement = document.getElementById('uptime');
                if (uptimeElement) {
                    uptimeElement.textContent = `${hours}h ${minutes}m`;
                }
                
                // Filter to only attack events
                const attackData = filterAttackEvents(logData);
                
                // Calculate actual statistics from attack data only
                if (attackData && attackData.length > 0) {
                    // Network attacks
                    const networkAttacks = attackData.filter(entry => {
                        const type = entry.event_type || '';
                        return ['DOS_FLOOD', 'DDOS', 'PORT_SCAN', 'BRUTE_FORCE', 'BRUTE_FORCE_ATTEMPT', 
                                'UNAUTHORIZED_ACCESS', 'WEB_EXPLOIT', 'AI_NETWORK_ATTACK'].includes(type);
                    }).length;
                    
                    // CCTV attacks
                    const cctvAttacks = attackData.filter(entry => {
                        const type = entry.event_type || '';
                        return ['VIDEO_INJECTION', 'FRAME_FREEZE', 'MOTION_MASKING', 'CABLE_CUTTING',
                                'OBSTRUCTION_DETECTED', 'OBSTRUCTION_SESSION', 'INJECT_ATTACK_SESSION',
                                'INJECT_ATTACK_TRIGGER', 'MANUAL_ATTACK_SESSION', 'MANUAL_ATTACK_TRIGGER'].includes(type);
                    }).length;
                    
                    const totalAttacks = attackData.length;
                    
                    // Update stats with real attack data
                    const totalAttacksEl = document.getElementById('total-attacks');
                    const networkAttacksEl = document.getElementById('network-attacks');
                    const cctvAttacksEl = document.getElementById('cctv-attacks');
                    
                    if (totalAttacksEl) totalAttacksEl.textContent = totalAttacks;
                    if (networkAttacksEl) networkAttacksEl.textContent = networkAttacks;
                    if (cctvAttacksEl) cctvAttacksEl.textContent = cctvAttacks;
                    
                    // Update global stats for other functions
                    eventStats = {
                        total: totalAttacks,
                        network: networkAttacks,
                        cctv: cctvAttacks
                    };
                    
                    // Update charts with attack data only
                    if (typeof updateCharts === 'function') {
                        updateCharts(attackData);
                    }
                    
                    // Update security score with attack data
                    if (typeof updateSecurityScore === 'function') {
                        updateSecurityScore(attackData);
                    }
                } else {
                    // Default to zero if no attack data
                    const totalAttacksEl = document.getElementById('total-attacks');
                    const networkAttacksEl = document.getElementById('network-attacks');
                    const cctvAttacksEl = document.getElementById('cctv-attacks');
                    
                    if (totalAttacksEl) totalAttacksEl.textContent = '0';
                    if (networkAttacksEl) networkAttacksEl.textContent = '0';
                    if (cctvAttacksEl) cctvAttacksEl.textContent = '0';
                    
                    // Clear charts
                    if (typeof clearCharts === 'function') {
                        clearCharts();
                    }
                }
            } finally {
                analyticsUpdateInProgress = false;
            }
        }

        function updateCharts(logData) {
            if (!logData || logData.length === 0) {
                clearCharts();
                return;
            }
            
            // Update pie chart
            drawPieChart(logData);
            
            // Update timeline chart
            drawTimelineChart(logData);
            
            // Update comparison charts
            drawHourlyComparison(logData);
            drawTypeBreakdown(logData);
        }

        function drawPieChart(logData) {
            const canvas = document.getElementById('event-pie-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const periodEl = document.getElementById('pie-chart-period');
            const period = periodEl ? periodEl.value : 'all';
            
            // Filter to only attack events
            const filteredData = filterDataByPeriod(logData, period);
            const attackData = filterAttackEvents(filteredData);
            
            if (attackData.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No attack data', canvas.width / 2, canvas.height / 2);
                const legendEl = document.getElementById('pie-legend');
                if (legendEl) legendEl.innerHTML = '';
                return;
            }
            
            // Count attack types with friendly names
            const eventCounts = {};
            attackData.forEach(entry => {
                const type = entry.event_type || 'UNKNOWN';
                const friendlyName = getAttackFriendlyName(type);
                eventCounts[friendlyName] = (eventCounts[friendlyName] || 0) + 1;
            });
            
            // Prepare data for pie chart with attack-specific colors
            const colors = {
                'DDoS/DoS Flood': '#dc3545',
                'Port Scan': '#ff6b6b',
                'Brute Force': '#ee5a6f',
                'Unauthorized Access': '#c44569',
                'Web Exploit': '#f8b500',
                'AI Network Attack': '#ffa502',
                'Video Injection': '#fd7e14',
                'Frame Freeze': '#ff6348',
                'Motion Masking': '#ff4757',
                'Cable Cutting': '#ff3838',
                'Obstruction': '#17a2b8',
                'Inject Attack': '#fd7e14',
                'Manual Attack': '#dc3545',
                'Alert': '#ff6b6b'
            };
            
            const data = Object.keys(eventCounts).map(type => ({
                label: type,
                value: eventCounts[type],
                color: colors[type] || '#17a2b8'
            }));
            
            // Draw pie chart
            drawPie(ctx, canvas.width, canvas.height, data);
            
            // Update legend
            updateLegend('pie-legend', data);
        }

        function drawPie(ctx, width, height, data) {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - 20;
            
            ctx.clearRect(0, 0, width, height);
            
            let total = data.reduce((sum, item) => sum + item.value, 0);
            let currentAngle = -Math.PI / 2;
            
            data.forEach(item => {
                const sliceAngle = (item.value / total) * 2 * Math.PI;
                
                // Draw slice
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = item.color;
                ctx.fill();
                
                // Draw label
                const labelAngle = currentAngle + sliceAngle / 2;
                const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
                const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
                
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${item.value}`, labelX, labelY);
                
                currentAngle += sliceAngle;
            });
        }

        function drawTimelineChart(logData) {
            const canvas = document.getElementById('timeline-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const periodEl = document.getElementById('timeline-period');
            const period = periodEl ? periodEl.value : 'hour';
            
            // Filter to only attack events
            const filteredData = filterDataByPeriod(logData, period);
            const attackData = filterAttackEvents(filteredData);
            
            if (attackData.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No attack data', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Group attack events by time
            const timeGroups = {};
            attackData.forEach(entry => {
                try {
                    const entryTime = entry.time || entry.timestamp;
                    if (!entryTime) return;
                    
                    let time;
                    if (typeof entryTime === 'string') {
                        time = new Date(entryTime);
                        if (isNaN(time.getTime())) {
                            time = new Date(entryTime.replace(/(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2})/, '$1T$2'));
                        }
                    } else {
                        time = new Date(entryTime);
                    }
                    
                    if (isNaN(time.getTime())) return;
                    
                    let key;
                    switch(period) {
                        case 'hour':
                            key = time.getMinutes();
                            break;
                        case 'day':
                            key = time.getHours();
                            break;
                        case 'week':
                            key = time.getDay();
                            break;
                        default:
                            key = time.getHours();
                    }
                    
                    if (!timeGroups[key]) {
                        timeGroups[key] = 0;
                    }
                    timeGroups[key]++;
                } catch (e) {
                    // Skip entries with invalid dates
                }
            });
            
            // Draw timeline
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const keys = Object.keys(timeGroups).sort((a, b) => a - b);
            const maxValue = Math.max(...Object.values(timeGroups));
            const barWidth = canvas.width / keys.length;
            const chartHeight = canvas.height - 40;
            
            ctx.fillStyle = '#007bff';
            keys.forEach((key, index) => {
                const value = timeGroups[key];
                const barHeight = (value / maxValue) * chartHeight;
                const x = index * barWidth;
                const y = canvas.height - barHeight - 20;
                
                ctx.fillRect(x + 5, y, barWidth - 10, barHeight);
                
                // Draw label
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(key, x + barWidth / 2, canvas.height - 5);
                
                ctx.fillStyle = '#007bff';
            });
        }

        function drawHourlyComparison(logData) {
            const canvas = document.getElementById('hourly-comparison');
            const ctx = canvas.getContext('2d');
            
            // Group by hour
            const hourlyData = {};
            for (let i = 0; i < 24; i++) {
                hourlyData[i] = 0;
            }
            
            logData.forEach(entry => {
                const hour = new Date(entry.time).getHours();
                hourlyData[hour]++;
            });
            
            // Draw bar chart
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const hours = Object.keys(hourlyData);
            const values = Object.values(hourlyData);
            const maxValue = Math.max(...values);
            const barWidth = canvas.width / 24;
            const chartHeight = canvas.height - 20;
            
            ctx.fillStyle = '#28a745';
            hours.forEach((hour, index) => {
                const value = hourlyData[hour];
                const barHeight = maxValue > 0 ? (value / maxValue) * chartHeight : 0;
                const x = index * barWidth;
                const y = canvas.height - barHeight - 10;
                
                ctx.fillRect(x + 1, y, barWidth - 2, barHeight);
            });
        }

        function drawTypeBreakdown(logData) {
            const canvas = document.getElementById('type-breakdown');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            // Filter to only attack events
            const attackData = filterAttackEvents(logData);
            
            if (attackData.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No attack data', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Count attack types with friendly names
            const typeCounts = {};
            attackData.forEach(entry => {
                const type = entry.event_type || 'UNKNOWN';
                const friendlyName = getAttackFriendlyName(type);
                typeCounts[friendlyName] = (typeCounts[friendlyName] || 0) + 1;
            });
            
            const types = Object.keys(typeCounts);
            const counts = Object.values(typeCounts);
            const maxCount = Math.max(...counts, 1);
            const barHeight = canvas.height / Math.max(types.length, 1);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const colors = {
                'DDoS/DoS Flood': '#dc3545',
                'Port Scan': '#ff6b6b',
                'Brute Force': '#ee5a6f',
                'Unauthorized Access': '#c44569',
                'Web Exploit': '#f8b500',
                'AI Network Attack': '#ffa502',
                'Video Injection': '#fd7e14',
                'Frame Freeze': '#ff6348',
                'Motion Masking': '#ff4757',
                'Cable Cutting': '#ff3838',
                'Obstruction': '#17a2b8',
                'Inject Attack': '#fd7e14',
                'Manual Attack': '#dc3545',
                'Alert': '#ff6b6b'
            };
            
            types.forEach((type, index) => {
                const count = typeCounts[type];
                const barWidth = maxCount > 0 ? (count / maxCount) * (canvas.width - 60) : 0;
                const y = index * barHeight;
                
                ctx.fillStyle = colors[type] || '#17a2b8';
                ctx.fillRect(50, y + 5, barWidth, barHeight - 10);
                
                // Draw label
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(type, 45, y + barHeight / 2 + 3);
            });
        }

        function updateSecurityScore(logData) {
            const totalEvents = logData.length;
            const alertEvents = logData.filter(entry => 
                entry.event_type === 'ALERT'
            ).length;
            
            // Calculate security score (0-100)
            let score = 100;
            
            // Deduct points for alerts
            score -= Math.min(alertEvents * 5, 50);
            
            // Deduct points for high frequency
            if (totalEvents > 100) score -= 20;
            else if (totalEvents > 50) score -= 10;
            
            score = Math.max(0, Math.min(100, score));
            
            // Update score display
            const scoreElement = document.getElementById('security-score');
            const scoreValue = scoreElement.querySelector('.score-value');
            scoreValue.textContent = score;
            
            // Update score circle gradient
            const degrees = (score / 100) * 360;
            scoreElement.style.background = `conic-gradient(#28a745 0deg ${degrees}deg, #dc3545 ${degrees}deg 360deg)`;
            
            // Update threat level
            const threatLevel = score > 80 ? 'Low' : score > 50 ? 'Medium' : 'High';
            document.getElementById('threat-level').textContent = threatLevel;
            
            // Update other metrics
            document.getElementById('response-time').textContent = (Math.random() * 3 + 1).toFixed(1) + 's';
            document.getElementById('accuracy').textContent = (95 + Math.random() * 5).toFixed(1) + '%';
        }

        function filterDataByPeriod(logData, period) {
            if (!logData || logData.length === 0) return [];
            
            const now = new Date();
            const cutoff = new Date();
            
            switch(period) {
                case 'hour':
                    cutoff.setHours(now.getHours() - 1);
                    break;
                case 'today':
                    cutoff.setHours(0, 0, 0, 0);
                    cutoff.setMinutes(0);
                    cutoff.setSeconds(0);
                    cutoff.setMilliseconds(0);
                    break;
                case 'day':
                    cutoff.setDate(now.getDate() - 1);
                    break;
                case 'week':
                    cutoff.setDate(now.getDate() - 7);
                    break;
                default:
                    return logData;
            }
            
            return logData.filter(entry => {
                try {
                    const entryTime = entry.time || entry.timestamp;
                    if (!entryTime) return false;
                    
                    // Try to parse as Date
                    let entryDate;
                    if (typeof entryTime === 'string') {
                        // Try ISO format first
                        entryDate = new Date(entryTime);
                        // If that fails, try the time format
                        if (isNaN(entryDate.getTime())) {
                            entryDate = new Date(entryTime.replace(/(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2})/, '$1T$2'));
                        }
                    } else {
                        entryDate = new Date(entryTime);
                    }
                    
                    return !isNaN(entryDate.getTime()) && entryDate >= cutoff;
                } catch (e) {
                    // If parsing fails, include the entry (better to show than hide)
                    return true;
                }
            });
        }

        function updateLegend(legendId, data) {
            const legend = document.getElementById(legendId);
            legend.innerHTML = '';
            
            data.forEach(item => {
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-color" style="background: ${item.color}"></div>
                    <span>${item.label}: ${item.value}</span>
                `;
                legend.appendChild(legendItem);
            });
        }

        function clearCharts() {
            const canvases = ['event-pie-chart', 'timeline-chart', 'hourly-comparison', 'type-breakdown'];
            canvases.forEach(id => {
                const canvas = document.getElementById(id);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });
            
            // Clear legend
            document.getElementById('pie-legend').innerHTML = '';
        }

        function playAlertSound() {
            try {
                // Use Web Audio API for better control
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Resume audio context if suspended (required by some browsers)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Higher frequency and louder for better visibility
                oscillator.frequency.value = 1000; // Higher pitch
                oscillator.type = 'sine';
                
                // Louder volume (0.5 instead of 0.3)
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.error('Error playing alert sound:', error);
                // Fallback: try using HTML5 Audio if Web Audio API fails
                try {
                    const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OSfTgwOUKfk8LZjHAY4kdfyzHksBSR3x/DdkEAKFF606euoVRQKRp/g8r5sIQUrgc7y2Yk2CBtpvfDkn04MDlCn5PC2YxwGOJHX8sx5LAUkd8fw3ZBAC');
                    audio.volume = 0.7;
                    audio.play().catch(e => console.error('Audio play failed:', e));
                } catch (e) {
                    console.error('Fallback audio also failed:', e);
                }
            }
        }

        // Settings functions
        function saveSettings() {
            const soundEnabled = document.getElementById('sound-toggle').classList.contains('active');
            const emailEnabled = document.getElementById('email-toggle').classList.contains('active');
            
            // Save to localStorage (in a real app, this would be saved to backend)
            localStorage.setItem('cctv-settings', JSON.stringify({
                soundEnabled: soundEnabled,
                emailEnabled: emailEnabled
            }));
            
            // Show success message
            showNotification('Settings saved successfully!', 'success');
        }

        function resetSettings() {
            if (confirm('Are you sure you want to reset all settings to default?')) {
                document.getElementById('sound-toggle').classList.remove('active');
                document.getElementById('email-toggle').classList.remove('active');
                localStorage.removeItem('cctv-settings');
                showNotification('Settings reset to default', 'info');
            }
        }

        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                background: ${type === 'success' ? '#28a745' : '#17a2b8'};
                color: white;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 1000;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Settings toggle handlers are now merged into the main DOMContentLoaded listener

        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // Cleanup on page unload
        window.onbeforeunload = function() {
            if (statusInterval) {
                clearInterval(statusInterval);
            }
        };
    </script>
</body>
</html>
